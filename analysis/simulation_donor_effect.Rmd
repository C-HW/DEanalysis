---
title: "Simulation for donor effect"
author: "Chih-Hsuan Wu"
output: html_document
---

```{r, setup, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
source("./code/DE_methods.R")
load("./data/splatter_simulation.RData") # the result generated by this rmd
library(Seurat)
library(pryr)
library(MAST)
library(dplyr)
library(muscat)
```

```{r}
library(splatter)
library(scater)

simulate_sce = function(donor_effect = 0.1, DE_effect = 0.1, s = 2024){
  # Set parameters
  ngenes <- 1000  # Total number of genes
  ncells <- 900   # Total number of cells
  nreps <- 3       # Number of replicates (donors)
  
  # Create splatter parameters
  params <- newSplatParams(
    nGenes = ngenes,        # Total genes
    batchCells = rep(ncells/nreps, nreps),    # Total cells
    batch.facLoc = donor_effect,
    batch.facScale = 0.1,
    group.prob = c(0.5, 0.5),  # Probability of cell types
    de.prob = c(0, 0.1),  # 10% of genes are DE (100 genes out of 1,000)
    de.facLoc = DE_effect,
    de.facScale = DE_effect,
    seed = s
  )
  sce = splatSimulate(params, method = "groups", verbose = FALSE)
  colnames(colData(sce))[2:3] = c("donor", "celltype")
  return(sce)
}

# Define a function to calculate FDR and power
calc_fdr_power <- function(de_results_genes, true_de_genes) {
  # FDR: proportion of false positives out of total positives
  true_positives = intersect(de_results_genes, true_de_genes)
  false_positives = setdiff(de_results_genes, true_de_genes)
  fdr = length(false_positives) / (length(de_results_genes) + 1e-8)
  
  # Power: proportion of true positives out of true DE genes
  power = length(true_positives) / length(true_de_genes)
  
  return(list(fdr = fdr, power = power))
}


```


```{r, eval = FALSE}
# Define configurations 
donor_effect_fac <- c(0.5, 1)
DE_effect_fac <- c(0.5, 1)

# Initialize a list to store results for each method and configuration
results <- list()
set.seed(1234)
iter_seed = sample(1:1000, 20)
# Loop through each configuration (2x2 design)
for (donor_effect in donor_effect_fac) {
  for (DE_effect in DE_effect_fac) {
    # Repeat simulation 20 times
  for (i in 1:20) {
    print(c("iter:", i, "donor:" , donor_effect, "DE:", DE_effect))
  # Simulate data
    sim_data <- simulate_sce(donor_effect
                             , DE_effect
                             , iter_seed[i]
                             )
    assays(sim_data)$cpm = edgeR::cpm(counts(sim_data))
    Seurat_sim_data =CreateSeuratObject(sim_data@assays@data$counts, project = "sim_data", assay = "RNA", meta.data = data.frame(colData(sim_data)))
    Idents(Seurat_sim_data) = "celltype"
  
    Seurat_sim_data = NormalizeData(Seurat_sim_data)
    true_de_genes <- rowData(sim_data)$Gene[rowData(sim_data)$DEFacGroup2!=1]  # Ground truth DE genes
  

    
    # poisson_glmm
    runtime <- system.time({
      memory_used <- mem_change({
        pois_glmm_df = poisson_glmm_DE(sim_data, comparison = "celltype", replicates = "donor")
        pois_glmm_df$hits = identifyDEGs(pois_glmm_df$BH, pois_glmm_df$log2FC, pois_glmm_df$log2mean, pois_glmm_df$log2meandiff, newcriteria = T)
        pois_glmm_df$hits_oldcriteria = identifyDEGs(pois_glmm_df$BH, pois_glmm_df$log2FC, newcriteria = F)
      })
    })
    # Calculate FDR and power
    metrics <- calc_fdr_power(pois_glmm_df$genes[which(pois_glmm_df$hits)], true_de_genes)
    metrics_old <- calc_fdr_power(pois_glmm_df$genes[which(pois_glmm_df$hits_oldcriteria)], true_de_genes)
    
    # Record results for this method, configuration, and run
    results[["Poisson-glmm_UMI_new"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]] <- 
      rbind(results[["Poisson-glmm_UMI_new"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]], 
            data.frame(FDR = metrics$fdr, 
                       Power = metrics$power, 
                       Runtime = runtime["elapsed"], 
                       Memory = memory_used))
    results[["Poisson-glmm_UMI_old"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]] <- 
      rbind(results[["Poisson-glmm_UMI_old"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]], 
            data.frame(FDR = metrics_old$fdr, 
                       Power = metrics_old$power, 
                       Runtime = runtime["elapsed"], 
                       Memory = memory_used))
  
  # binom_glmm
    runtime <- system.time({
      memory_used <- mem_change({
        binom_glmm_df = binomial_glmm_DE(sim_data, comparison = "celltype", replicates = "donor")
        binom_glmm_df$hits = identifyDEGs(binom_glmm_df$BH, binom_glmm_df$log2FC, binom_glmm_df$log2mean, binom_glmm_df$log2meandiff, newcriteria = T)
      })
    })
    
    # Calculate FDR and power
    metrics <- calc_fdr_power(binom_glmm_df$genes[which(binom_glmm_df$hits)], true_de_genes)
    
    # Record results for this method, configuration, and run
    results[["Binomial-glmm_UMI"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]] <- 
      rbind(results[["Binomial-glmm_UMI"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]], 
            data.frame(FDR = metrics$fdr, 
                       Power = metrics$power, 
                       Runtime = runtime["elapsed"], 
                       Memory = memory_used))
    
  
    # MAST
    runtime <- system.time({
      memory_used <- mem_change({
      MAST_donor_df = MAST_DE(sim_data, sim_data$celltype, sim_data$donor)
      MAST_donor_df$hits = identifyDEGs(MAST_donor_df$BH, MAST_donor_df$log2FC, newcriteria = F)
      })
    })
    # Calculate FDR and power
    metrics <- calc_fdr_power(MAST_donor_df$genes[which(MAST_donor_df$hits)], true_de_genes)
    # Record results for this method, configuration, and run
    results[["MAST_CPM"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]] <- 
        rbind(results[["MAST_CPM"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]], 
              data.frame(FDR = metrics$fdr, 
                         Power = metrics$power, 
                         Runtime = runtime["elapsed"], 
                         Memory = memory_used))
    # Wilcox
    runtime <- system.time({
      memory_used <- mem_change({
        Wilcox_Seurat_df = FindMarkers(Seurat_sim_data, ident.1 = "Group1", ident.2 = "Group2", test.use = "wilcox")
        Wilcox_Seurat_df$genes = rownames(Wilcox_Seurat_df)
        Wilcox_Seurat_df$hits = identifyDEGs(Wilcox_Seurat_df$p_val_adj, Wilcox_Seurat_df$avg_log2FC, newcriteria = F)
      })
    })
    # Calculate FDR and power
    metrics <- calc_fdr_power(Wilcox_Seurat_df$genes[which(Wilcox_Seurat_df$hits)], true_de_genes)
    # Record results for this method, configuration, and run
    results[["Wilcox_Norm"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]] <- 
        rbind(results[["Wilcox_Norm"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]], 
              data.frame(FDR = metrics$fdr, 
                         Power = metrics$power, 
                         Runtime = runtime["elapsed"], 
                         Memory = memory_used))
  
    sim_data$cluster_id = "void"
    sim_data$group_id = sim_data$celltype
    sim_data$sample_id = as.factor(paste0(sim_data$celltype, sim_data$donor))
    # sim_data$sample_id = as.factor(sim_data$donor)
    sim_data = prepSCE(sim_data,
                        kid = "cluster_id", 
                        gid = "group_id",
                        sid = "sample_id",
                        drop = FALSE)
      # DESeq2.muscat
    runtime <- system.time({       
      memory_used <- mem_change({
        pb = aggregateData(sim_data,
          assay = "counts", fun = "sum",
          by = c("cluster_id","sample_id"))
        res = pbDS(pb, method = "DESeq2", verbose = F)
        DESeq2.muscat = data.frame(res$table[[1]][[1]])[,c(1,4,7,8)]
        DESeq2.muscat$logFC = log2(exp(DESeq2.muscat$logFC))
        colnames(DESeq2.muscat) = c("genes", "log2FC", "pval", "BH")
        DESeq2.muscat$hits = identifyDEGs(DESeq2.muscat$BH, DESeq2.muscat$log2FC, newcriteria = F)
      })
    })
    # Calculate FDR and power
    metrics <- calc_fdr_power(DESeq2.muscat$genes[which(DESeq2.muscat$hits)], true_de_genes)
    # Record results for this method, configuration, and run
    results[["pb-DESeq2_UMI"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]] <- 
        rbind(results[["pb-DESeq2_UMI"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]], 
              data.frame(FDR = metrics$fdr, 
                         Power = metrics$power, 
                         Runtime = runtime["elapsed"], 
                         Memory = memory_used))
      
    # edgeR.sum.cpm
    runtime <- system.time({       
      memory_used <- mem_change({
        pb = aggregateData(sim_data,
          assay = "cpm", fun = "sum",
          by = c("cluster_id", "sample_id"))
        res = pbDS(pb, method = "edgeR", verbose = FALSE)
        edgeR.cpm = data.frame(res$table[[1]][[1]])[,c(1,3,6,7)]
        edgeR.cpm$logFC = log2(exp(edgeR.cpm$logFC))
        colnames(edgeR.cpm)[1:4] = c("genes", "log2FC", "pval", "BH")
        edgeR.cpm$hits = identifyDEGs(edgeR.cpm$BH, edgeR.cpm$log2FC, newcriteria = F)
      })
    })
    
    # Calculate FDR and power
    metrics <- calc_fdr_power(edgeR.cpm$genes[which(edgeR.cpm$hits)], true_de_genes)
    
    # Record results for this method, configuration, and run
    results[["pb-edgeR_cpm"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]] <- 
        rbind(results[["pb-edgeR_cpm"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]], 
              data.frame(FDR = metrics$fdr, 
                         Power = metrics$power, 
                         Runtime = runtime["elapsed"], 
                         Memory = memory_used))
    
    # MM-vst
    runtime <- system.time({       
      memory_used <- mem_change({
        res = mmDS(sim_data, method = "vst", vst = "DESeq2")
        MMvst = data.frame(res[[1]])[,c(1,3,6,7)]
        MMvst$beta = log2(exp(MMvst$beta))
        colnames(MMvst)[1:4] = c("genes", "log2FC", "pval", "BH")
        MMvst$hits = identifyDEGs(MMvst$BH, MMvst$log2FC, newcriteria = F)
      })
    })
    
    # Calculate FDR and power
    metrics <- calc_fdr_power(MMvst$genes[which(MMvst$hits)], true_de_genes)
    # Record results for this method, configuration, and run
    results[["MMvst_VST"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]] <- 
        rbind(results[["MMvst_VST"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]], 
              data.frame(FDR = metrics$fdr, 
                         Power = metrics$power, 
                         Runtime = runtime["elapsed"], 
                         Memory = memory_used))
      
    # MM-poisson
    runtime <- system.time({       
      memory_used <- mem_change({
    res = mmDS(sim_data, method = "poisson")
      MMpoisson = data.frame(res[[1]])[,c(1,3,6,7)]
      MMpoisson$beta = log2(exp(MMpoisson$beta))
      colnames(MMpoisson)[1:4] = c("genes", "log2FC", "pval", "BH")
      MMpoisson$hits = identifyDEGs(MMpoisson$BH,                                    MMpoisson$log2FC, newcriteria = F)
      })
    })
    # Calculate FDR and power
    metrics <- calc_fdr_power(MMpoisson$genes[which(MMpoisson$hits)], true_de_genes)
    # Record results for this method, configuration, and run
    results[["MMpoisson_UMI"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]] <- 
        rbind(results[["MMpoisson_UMI"]][[paste0("Donor",donor_effect, "_DE", DE_effect)]], 
              data.frame(FDR = metrics$fdr, 
                         Power = metrics$power, 
                         Runtime = runtime["elapsed"], 
                         Memory = memory_used))
  }
  }
}

# Compute average performance metrics for each method and configuration
average_results <- lapply(results, function(method_res) {
  lapply(method_res, function(res) {
    res %>%
      summarise(Avg_FDR = mean(FDR), 
                Avg_Power = mean(Power), 
                Avg_Runtime = mean(Runtime), 
                Avg_Memory = mean(Memory))
  })
})
```


# Visulization of Donor effect and DE effect
```{r, fig.width=10}
library(gridExtra)
# View simulation summary
for (donor_effect in c(0.5, 1)){
  for (DE_effect in c(0.5, 1)){
    sim_data = simulate_sce(donor_effect, DE_effect)
    sim_data <- computeLibraryFactors(sim_data)
    sim_data <- logNormCounts(sim_data)
    sim_data = runPCA(sim_data)
    p1 = plotPCA(sim_data, colour_by = "donor") +
      ggtitle(paste("Donor effect", donor_effect, "DE effect", DE_effect))
    p2 = plotPCA(sim_data, colour_by = "celltype") +
      ggtitle(paste("Donor effect", donor_effect, "DE effect", DE_effect)) 
    # Plot side by side
    grid.arrange(p1, p2, ncol = 2)
  }
}
```

```{r}
library(ggplot2)

gene_data <- data.frame(
  library_size = sim_data$ExpLibSize,
  group = sim_data$celltype)

# Plot the histogram with density curves
ggplot(gene_data, aes(x = library_size, fill = group)) +
  geom_histogram(aes(y = ..density..), binwidth = 5000, alpha = 0.5, position = "identity") +
  geom_density(alpha = 0.7) +
  scale_fill_manual(values = c("Group1" = "#69b3a2", "Group2" = "#404080")) +
  labs(title = "Histogram with Density of Gene Expression Library Size",
       x = "Library Size",
       y = "Density") +
  theme_minimal()
```

# Simulation results
```{r}
# Initialize an empty data frame
combined_results <- data.frame()

# Loop over each method and its configurations
for (method in names(results)) {
  for (config in names(results[[method]])) {
    # Extract the data frame for this method and config
    df <- results[[method]][[config]]
    
    # Add columns for method and configuration to the data frame
    df$Method <- method
    df$Configuration <- config
    
    # Combine the results
    combined_results <- rbind(combined_results, df)
  }
}
combined_results$Method = factor(combined_results$Method, levels = names(results))
```

```{r, fig.width=14}
ggplot(combined_results, aes(x = Method, y = FDR, fill = Configuration)) +
  geom_boxplot() +
  theme_minimal() +
  labs(y = "False Discovery Rate (FDR)", x = "Method", title = "FDR Across Methods and Configurations") +
  theme_bw() + 
  theme(panel.grid = element_blank()) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))
  

```

```{r, fig.width=14}
ggplot(combined_results, aes(x = Method, y = Power, fill = Configuration)) +
  geom_boxplot() +
  theme_minimal() +
  labs(y = "Power", x = "Method", title = "Power Across Methods and Configurations") +
  theme_bw() + 
  theme(panel.grid = element_blank()) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))
  

```

```{r, fig.width=14}
library(tidyr)
library(dplyr)
result_long <- combined_results %>%
  pivot_longer(cols = c("Power", "FDR"), names_to = "metric", values_to = "value")
# Create a facetted plot comparing methods and configurations
ggplot(result_long, aes(x = Method, y = value, fill = metric)) +
  geom_boxplot() + 
  facet_wrap(~Configuration) +  # Facet by configuration
  labs(title = "Power and FDR Comparison across Methods and Configurations",
       x = "Method", y = "Metric Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = c("Power" = "skyblue", "FDR" = "salmon"))  # Customize colors
```
```{r}
ggplot(combined_results, aes(x = Configuration, y = Runtime, group = Method, color = Method)) +
  geom_line() +
  geom_point() +
  theme_minimal() +
  labs(y = "Runtime(s)", x = "Configuration", title = "Memory Usage Across Configurations")
library(dplyr)

# Create and sort the summary table
runtime_table <- combined_results %>%
  group_by(Configuration, Method) %>%
  summarize(Average_Runtime = mean(Runtime), .groups = 'drop') %>%
  arrange(Method, Configuration)  # Sort by Method, then Configuration

# Display the table
print(runtime_table, n = 36)

# save(results, file = "./data/splatter_simulation.RData")
```

